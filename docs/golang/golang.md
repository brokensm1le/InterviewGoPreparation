# GO

## ООП

### Инкапсуляция

##### Что это такое? 

Все важные данные, которые требуются для функционирования объекта, должны хранится в нем самом. Лишь некоторая информация доступна для внешних элементов.

Внутри объекта или класса хранятся все данные этого объекта или класса. Таким образом, разработчик не может их редактировать при помощи других классов. Окружающие элементы могут лишь запрашивать «публичные» методы и атрибуты.

##### Как устроена в Go?

Go обеспечивает инкапсуляцию на уровне пакета. Единственный механизм управления видимостью — использование прописных и строчных букв.

Идентификаторы с прописной (заглавной) буквы экспортируются. В нашем примере структура Watch и ее методы GetTime и SetTime — экспортируется, то есть доступы за пределами пакета.

Идентификаторы со строчной (маленькой) буквы не экспортируются. В нашем примере поля структуры Watch: hours и minutes будут доступны только из того же пакета, за пределами к ним обратиться и вызвать их нельзя.


### Наследование

##### Что это такое? 

Наследование представляет собой метод организации объектов и классов. Чтобы разработчику не приходилось собственноручно создавать множество элементов, он может сформировать класс над классами. Они будут иметь более общие характеристики и функции. В результате программист может поэтапно наследовать от них какие-либо возможности.

##### Как устроена в Go?

В классическом виде никак, то есть мы не можем наследовать один объект от другого. Вместо наследования используют композицию — разделение крупных структур на более мелкие для их последующего объединения. Базовая структура встраивается в дочернюю, после чего базовые поля и методы напрямую доступы дочерней структуре.

Композиция определяет класс как сумму его частей, в то время как при наследовании мы получаем один класс из другого. Классы и объекты, созданные с использованием наследования, тесно связаны, и изменение родителя может сломать код. Структуры, созданные с помощью композиции, слабо связаны, можно легко изменять составные части, не нарушая код. 

### Полиморфизм

##### Что это такое? 

Одни и те же методы могут применяться для обработки различных типов информации. В разных ЯП полиморфизм имеет различные свойства.

##### Как устроена в Go?

Через интерфейсы. Мы можем определить интерфейс с набором методов и затем реализовать этот интерфейс разными структурами.



## Основные части Go


### Slice

### String

### Map (hash table)

### Goroutine (wait group)

### Замыкания

Замыкание функции — это значение функции, ссылающееся на переменные вне ее тела. Такая функция может обращаться к этим переменным и присваивать им значения.

```
package main
import "fmt"

func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    pos, neg := adder(), adder()
    for i := 0; i < 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}

Result:
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90

```
## Stack and heap

https://habr.com/ru/companies/oleg-bunin/articles/676332/

Как я могу знать, где Golang выделяет память под переменные — в хип или в стек?

Посмотреть, где у вас выделяются значения — на хипе или на стеке — можно путем команды: go build -gcflags=«-m». Причём, чем больше букв m, тем более подробно будет выведена информация.

Тем не менее разработчики языка гарантируют, что Golang всегда будет стараться выделить значение переменных на стеке, кроме некоторых исключительных ситуаций. Чтобы выяснить их, рассмотрим Escape Analysis. Escape Analysis — это механизм, который решает, будет ли храниться значение на стеке или на хипе.

#### Аллокация
*Аллокатор* хип основан на TCMalloc (Thread-Caching Allocator). Главная идея заключается в «слоистом» представлении памяти и в отдельных блоках памяти для каждого треда, в которые он обращается без lock.

Рассмотрим это более детально, но уже в языке Go. Представим, что у нас есть какое-то приложение и где-то есть виртуальная память для него. Мы говорим: «Дай нам, пожалуйста, кусочек памяти», и ОС его дает. Все замечательно. Но что произойдет, если мы внезапно захотим много кусочков памяти? В этом случае у нас произойдёт падение производительности.

Как с этим борются в Golang? Очень просто. Они просят не маленький кусочек памяти, а сразу огромный кусок, а потом решают, что с ним делать. Этот кусок памяти в аллокаторе называется ареной. Когда арена заканчивается, запрашивается ещё арена, и ещё арена, и ещё арена.
Важно подчеркнуть, что арена — это не просто кусок памяти. Как только мы получаем арену, например, в 64мб, то она сразу будет поделена на 8kb странички.

Арены и странички (arena и pages) не имеют никакой метаинформации о них. Это просто вшитые константы, которые вычисляются на момент компиляции. Всем этим свором (аренами и страничками) управляет «мама»-структура — heap arena или mheap в самом аллокаторе.
____

Есть три неизменяемых правила выделения памяти от версии к версии Golang. У вас 100% выделится значение на хипе, если:

Возврат результата происходит по ссылке;

Значение передается в аргумент типа interface{} — аргумент fmt.Println;

Размер значения переменной превышает лимиты стека.

## GC

https://habr.com/ru/amp/publications/753244/

Mark and Sweep — популярный алгоритм для сборщиков мусора. Он или его модификации много лет работают сейчас или работали ранее в Java, Python, Lua и других языках. Его работа состоит из 2 фаз:

- Mark: находим и отмечаем все достижимые объекты из набора (например, в куче).
- Sweep: проходим по всем объектам в куче, затираем недостижимые и возвращаем их в пул свободной памяти.

Чтобы операция по освобождению памяти прошла корректно, программа должна быть приостановлена во время стадии разметки (Mark). Такая пауза в выполнении называется Stop The World (STW). 
STW — очевидное зло с точки зрения перфоманса приложений. Любой язык с механизмом сборки мусора стремится сократить его влияние до минимума.


## Прикольные фичи

##### Дополнительный блок фигурных скобок в функции. Зачем он нужен?

Он нужен для АСД(Абстрактное синтаксическое дерево), типо если у нас есть очень длинная функция и мы по какой-то причине не можем её декомпозировать. ТО нам помогут {}
