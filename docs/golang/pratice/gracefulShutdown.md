# Graceful Shutdown

Материал взят из статьи: https://habr.com/ru/articles/908344/

## Сигналы

Корректное завершение любого приложения обычно делает три вещи:

1. Закрывает точку входа для новых запросов или сообщений из HTTP, pub/sub источников и т.д. При этом исходящие соединения с базами данных, кешами сохраняются активными.
2. Ждет завершения всех исходящих запросов. Если запрос работает слишком долго, возвращается корректная ошибка. 
3. Освобождает важные ресурсы, как базы данных, блокировки на файлы или подписки на сетевые источники.

По умолчанию рантайм Go завершает приложение при получении сигналов SIGTERM , SIGINT или SIGHUP.

> Когда ваше приложение на Go получает SIGTERM в первый раз используется встроенный обработчик. Он проверяет, 
> зарегистрирован ли отдельный обработчик. Если отдельного обработчика нет, то рантайм временно блокирует свой встроенный 
> обработчик и посылает тот же сигнал (SIGTERM) в приложение снова. В этот момент, операционная система обрабатывает второй 
> сигнал по-умолчанию (завершение процесса).


Можно зарегистрировать собственный обработчик системных сигналов через пакет `os/signal` :

```go
package main

func main() {
  signalChan := make(chan os.Signal, 1)
  signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)

  // Setup work here

  <-signalChan

  fmt.Println("Received termination signal, shutting down...")
}
```


## Таймаут

Важно знать сколько времени есть у приложения на завершение после получения сигнала. К примеру в Kubernetes по-умолчанию 
это 30 секунд, который можно переопределить в поле terminationGracePeriodSeconds . После завершения этого периода, 
Kubernetes принудительно посылает  SIGKILL для завершения приложения. Этот сигнал не может быть перехвачен или обработан.


Пусть по-умолчанию у нас есть 30 секунд. Хорошей практикой будет резервирование 20% от этого периода для запаса прочности,
чтобы остановка приложения выполнилась точно после очистки ресурсов. Таким образом для корректного завершения работы 
приложения нам нужно угнать сделать это за 25 секунд.

## Новые входящие запросы

Метод `server.Shutdown` возвращает управление только в двух ситуациях:

- все активные соединения закрыты и все обработчики закончили свою работу
- контекст переданный в Shutdown(ctx) закончился по времени до момента, когда все обработчики закончили свою работу. В этом случае сервер перестает ждать.

```go
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
)

func main() {
	var srvк http.Server

	idleConnsClosed := make(chan struct{})
	go func() {
		sigint := make(chan os.Signal, 1)
		signal.Notify(sigint, os.Interrupt)
		<-sigint

		// We received an interrupt signal, shut down.
		if err := srv.Shutdown(context.Background()); err != nil {
			// Error from closing listeners, or context timeout:
			log.Printf("HTTP server Shutdown: %v", err)
		}		
		close(idleConnsClosed)
	}()

	if err := srv.ListenAndServe(); err != http.ErrServerClosed {
		// Error starting or closing listener:
		log.Fatalf("HTTP server ListenAndServe: %v", err)
	}

	<-idleConnsClosed
}
```

## Старые запросы 

В любом случае, Shutdown возвращает управление после того, как сервер полностью остановил обработку входящих запросов. 
По этой причине, ваши обработчики должны быть быстрыми и учитывать контекст. Иначе сервер может прервать их работу на 
середине, а это приводит к проблемам неконсистентности - частичная запись, потеря всех или части данных, открытые транзакции,
повреждение данных.

Проблема в том, что обработчики по-умолчанию не знают, когда сервер завершает работу.

Тогда как мы можем узнать в обработчике, что сервер в процессе завершения работы? Ответ - использовать Context. 
Есть два основных пути сделать это:

1. Использовать middleware в Context для логики отмены запроса

Специальный метод оборачивает каждый запрос с контекстом, который слушает сигнал завершения работы:
```go

func WithGracefulShutdown(next http.Handler, cancelCh <-chan struct{}) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx, cancel := WithCancellation(r.Context(), cancelCh)
        defer cancel()

        r = r.WithContext(ctx)
        next.ServeHTTP(w, r)
	})
}
```
2. Использовать глобальный BaseContext для всех соединений

Здесь мы создаем сервер с кастомным Context , с функцией отмены - она вызовется в процессе остановки сервера. 
Этот контекст будет передаваться во все входящие запросы:
```go

ongoingCtx, cancelFn := context.WithCancel(context.Background())
server := &http.Server{
    Addr: ":8080",
    Handler: yourHandler,
    BaseContext: func(l net.Listener) context.Context {
        return ongoingCtx
    },
}

// After attempting graceful shutdown:
cancelFn()
time.Sleep(5 * time.Second) // optional delay to allow context propagation

```


Ключевой принцип корректного завершения работы остается практически одинаковым для всех систем: останавливаем прием данных
(запросы, сообщения, сигналы), даем текущим операциям время на завершение с заранее определенным периодом.

## Освобождение критических ресурсов

Распространенная ошибка - освобождать ресурсы как только придет сигнал о завершении. В этот момент обработчики и текущие
запросы могут еще использовать эти ресурсы. Вам нужна задержка перед освобождением ресурсов, пока не сработает таймаут 
завершения или все текущие запросы обработаются.

В большинстве случаев, завершение процесса вполне достаточно. Операционная система автоматически освободит ресурсы. Например:
- память выделенная Go рантаймом, автоматически освобождается при завершении процесса
- файловые дескрипторы закрываются операционной системой
- ресурсы уровня операционной системы (как обработчики процесса) - освобождаются

Однако есть несколько важных случаев, когда нужно явно освобождать ресурсы:
- коннекты к базам данных должны быть закрыты. Если есть открытые транзакции, их нужно либо закоммитить, либо откатить.
Без этого база данных будет ждать таймаута.
- очереди сообщений и брокеры часто также требуют явного закрытия. При этом сообщения могут очищаться, фиксироваться 
смещения или отправляется сигнал брокеру, что клиент закрывает соединение. Без этого можно поймать проблемы ребалансировки или потери сообщений.
- внешние сервисы могут не сразу понять, что клиент отключился. Закрытие коннекта вручную позволяет таким системам 
быстрее очищать ресурсы, не дожидаясь таймаутов по TCP.
  


Хорошее правило - закрывать компоненты в обратном порядке от инициализации. Это учитывает зависимости между компонентами.
Ключевое слово Go defer работает именно так - последняя deferred функция вызывается первой:

```go
db := connectDB()
defer db.Close()

cache := connectCache()
defer cache.Close()
```
